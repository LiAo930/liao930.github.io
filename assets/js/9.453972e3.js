(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{209:function(t,r,e){"use strict";e.r(r);var i=e(0),_=Object(i.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"窗口对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#窗口对象"}},[t._v("#")]),t._v(" 窗口对象")]),t._v(" "),e("ul",[e("li",[t._v("最基本的窗口对象是window，具有一个top的别名，也是全局作用的作用对象。一切在全局作用域下声明的变量和方法都会成为它的属性；")]),t._v(" "),e("li",[t._v("当页面引入多个、多层frame时，应该用top作为最顶层对象的名称，因为每一个frame都有自己的window对象；")]),t._v(" "),e("li",[t._v("parent对象指向当前frame的window对象的上层window对象")]),t._v(" "),e("li",[t._v("parent和top都是当前frame的window对象的属性")])]),t._v(" "),e("h3",{attrs:{id:"窗口位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#窗口位置"}},[t._v("#")]),t._v(" 窗口位置")]),t._v(" "),e("ul",[e("li",[t._v("不同浏览器有不同的计算属性，除firefox使用screenX和screenY来提供窗口位置信息，chrome，opera除了这两个属性外还使用screenLeft和screenTop表示当前窗口的位置信息；")]),t._v(" "),e("li",[t._v("这些属性都是挂载在window对象上的属性，都是窗口相对于整个屏幕的位置信息；")]),t._v(" "),e("li",[t._v("当某个窗口最大化之后其screenTop和screenLeft就永远为0；")]),t._v(" "),e("li",[t._v("控制位置的方法有：window.moveTo/moveBy，前者会指定窗口移动的具体坐标，后者单纯移动；")]),t._v(" "),e("li",[t._v("只有通过window.open打开的页面才支持这两个方法，剩下的统统无效")])]),t._v(" "),e("h3",{attrs:{id:"窗口大小："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#窗口大小："}},[t._v("#")]),t._v(" 窗口大小：")]),t._v(" "),e("ul",[e("li",[t._v("outerWidth/outerHeight：返回浏览器本身的宽高")]),t._v(" "),e("li",[t._v("innerWidth/innerHeight：返回页面可视区的宽高")]),t._v(" "),e("li",[t._v("document.documentElement.clientWidth/clientHeight：纯可视区（不包含滚动条）的宽高")]),t._v(" "),e("li",[t._v("resizeTo/resizeBy，前者设定指定大小，后者设定值为新窗口和旧窗口宽高之差，且这两个方法只能在通过window.open创建的页面上使用")])]),t._v(" "),e("h3",{attrs:{id:"导航"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#导航"}},[t._v("#")]),t._v(" 导航")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("window.open(url，target，arrributes_string，是否取代当前浏览器打开页面历史的布尔值)")]),t._v(" "),e("p",[t._v("url：加载的路由；")]),t._v(" "),e("p",[t._v("target：如果值为一个已经存在的窗口或frame，则在该窗口或frame加载路由；否则创建一个新窗口且名为target的值。另外，target也可以为_self,_parent,_top或_blank，分别代表不同的页面打开方式")])]),t._v(" "),e("li",[e("p",[t._v("window.open方法会返回一个类window对象，我们可以通过调整该对象来调整新打开的窗口。该对象还支持close方法来关闭打开的页面")])]),t._v(" "),e("li",[e("p",[t._v("方法返回的对象上还有一个opener属性，指向调用方法的窗口或框架。但框架上并不存在这种属性，因此如果想追踪只能手动。")])])]),t._v(" "),e("h3",{attrs:{id:"对话框："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对话框："}},[t._v("#")]),t._v(" 对话框：")]),t._v(" "),e("ul",[e("li",[t._v("系统对话框的样式无法由css改变，只能依据浏览器变化")]),t._v(" "),e("li",[t._v("alert(text)：显示text和一个确定按钮")]),t._v(" "),e("li",[t._v("confirm(text)：显示一段文本和确定/取消按钮，方法返回一个布尔值")]),t._v(" "),e("li",[t._v("prompt(text,default_input_text)：显示一段文本和一个输入框，输入框中是一段设定的默认值，还有确定/取消按钮。确定则返回输入值，否则返回null")])]),t._v(" "),e("h3",{attrs:{id:"location对象："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#location对象："}},[t._v("#")]),t._v(" location对象：")]),t._v(" "),e("ul",[e("li",[t._v("提供了有关当前窗口的信息，附带导航功能；")]),t._v(" "),e("li",[t._v("对象主要属性：\n"),e("ol",[e("li",[t._v("hash：返回url中的hash；")]),t._v(" "),e("li",[t._v("host：返回服务器的名称和端口号；")]),t._v(" "),e("li",[t._v("hostname：返回服务器名称；")]),t._v(" "),e("li",[t._v("href：返回完整url，location对象的toString方法也返回同样的值；")]),t._v(" "),e("li",[t._v("pathname：返回url中的目录和文件名；")]),t._v(" "),e("li",[t._v("port：返回端口号；")]),t._v(" "),e("li",[t._v("protocol：返回使用的协议；")]),t._v(" "),e("li",[t._v("search：返回url中的查询字符串，可以用URLSearchParams对象封装，有很多方便的api；")])])]),t._v(" "),e("li",[t._v("位置操作：\n"),e("ol",[e("li",[t._v("location.assign(url)：立即打开新url并在浏览器历史记录中生成新纪录。location.href = url、window.location = url也能做到相同的事；")]),t._v(" "),e("li",[t._v("每次修改location的属性值，页面都会以新url重新加载且生成记录；")]),t._v(" "),e("li",[t._v("如果不想生成记录，就用replace方法；")]),t._v(" "),e("li",[t._v("reload：无需参数，只需要调用就能刷新页面")])])])]),t._v(" "),e("h3",{attrs:{id:"navigation对象："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#navigation对象："}},[t._v("#")]),t._v(" navigation对象：")]),t._v(" "),e("ul",[e("li",[t._v("浏览器对象，属性大部分都是表述当前浏览器的具体信息的。如plugins代表浏览器中安装的插件信息数组，可以利用它来检测是否安装某些插件")]),t._v(" "),e("li",[t._v("registerContentHandler/registerProtocolHandler：h5方法，让一个站点指明它可以处理特定类型的信息；")]),t._v(" "),e("li",[t._v("registerContentHandler（要处理的MIME类型，可以处理该MIME类型的url，应用程序名称）")]),t._v(" "),e("li",[t._v("registerContentHandler（要处理的协议类型，可以处理该协议类型的url，应用程序名称）")])]),t._v(" "),e("h3",{attrs:{id:"screen对象："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#screen对象："}},[t._v("#")]),t._v(" screen对象：")]),t._v(" "),e("ul",[e("li",[t._v("表明浏览器参数信息")])]),t._v(" "),e("h3",{attrs:{id:"history对象："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#history对象："}},[t._v("#")]),t._v(" history对象：")]),t._v(" "),e("ul",[e("li",[t._v("window对象属性，保存用户访问过的url信息")]),t._v(" "),e("li",[t._v("具有三个属性，length最重要，表示访问过的url数量")]),t._v(" "),e("li",[t._v("go(number / url)：传入number时则会前进/后退对应的页数，正数前进，负数后退；传入url，如果访问过该url则跳转到该页面，否则无响应")]),t._v(" "),e("li",[t._v("forward/back：前进/后退一页")])])])}),[],!1,null,null,null);r.default=_.exports}}]);